<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>node - Jake Gardner</title><description>Explorations in development.</description><link>http://localhost:2368/</link><generator>Ghost 0.5</generator><lastBuildDate>Thu, 03 Mar 2016 07:24:29 GMT</lastBuildDate><atom:link href="http://localhost:2368/tag/node/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Testing CLI Tools</title><description>&lt;p&gt;While I was developing the &lt;a href="https://www.npmjs.com/package/s3syncr"&gt;s3syncr&lt;/a&gt; command-line (CLI) utility, I discovered I needed a way to test the function of the program as a whole. There are separate tests for the parsing of input to the program, but I wanted to verify the interaction of all the components as well as the output. &lt;/p&gt;

&lt;p&gt;Since console output is the only interface given to the user in a CLI tool, consistent output is critical.&lt;/p&gt;

&lt;p&gt;So, I made use of Node to run the utility inside a Mocha test.&lt;/p&gt;

&lt;h4 id="nodeexec"&gt;Node exec()&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;describe("No parameters", function() {
    it("should output No operation", function(done) {
        require('child_process').exec("node index.js",  
            function(err, stdout, stderr) {
              assert(err);
              assert.strictEqual(stderr, "No operation\n");
              done();  
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This test uses the Node-native &lt;a href="https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback"&gt;child_process.exec&lt;/a&gt; method which runs a shell command and gives you access to what is written to console.log() and console.error() through the &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; parameters, respectively. You can also pass in an options object to specify current working directory, environment variables and so on.&lt;/p&gt;

&lt;h4 id="assertingoutput"&gt;Asserting Output&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;assert.strictEqual(stderr, "No operation\n");
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that console output is available, to execute tests you just need to assert on &lt;code&gt;stdout&lt;/code&gt; or &lt;code&gt;stderr&lt;/code&gt; string content. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assert(err);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use the &lt;code&gt;err&lt;/code&gt; parameter to check for uncaught exceptions.&lt;/p&gt;

&lt;h4 id="automatinginput"&gt;Automating Input&lt;/h4&gt;

&lt;p&gt;Using exec() in the before and after &lt;a href="https://mochajs.org/#hooks"&gt;test hooks&lt;/a&gt; to handle varying test input gives you a path towards comprehensive automated testing!&lt;/p&gt;

&lt;p&gt;For example, you can have some tests that create a file, run the test, and then remove the file afterwards.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beforeEach(function(done) {
    require('child_process').exec("echo 'test' &amp;gt; test.txt", 
        function(err, stdout, stderr) {
            done();
    });
});

afterEach(function(done) {
    require('child_process').exec("rm test.txt", 
        function(err, stdout, stderr) {
            done();
    });
});

it("should output something", function(done) {
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="wrapup"&gt;Wrap Up&lt;/h4&gt;

&lt;p&gt;If you write any kind of CLI, this is a simple way to verify output.&lt;/p&gt;

&lt;p&gt;Honestly, this kind of test could be done in any scripting language, but using Node and Mocha allowed me to integrate with the rest of the testing suite.&lt;/p&gt;</description><link>http://localhost:2368/testing-cli-tools/</link><guid isPermaLink="false">c1447f66-a81e-4c93-b108-e6489972050b</guid><category>node</category><category>testing</category><dc:creator>Jake Gardner</dc:creator><pubDate>Tue, 15 Dec 2015 13:17:10 GMT</pubDate></item><item><title>Publish your Angular app to Heroku</title><description>&lt;p&gt;&lt;a href="https://www.heroku.com/"&gt;Heroku&lt;/a&gt; is great for hosting your development projects (particularly in-progress). In fact, I recommend publishing your project sooner rather than later so that you don't have any surprises in deployment later on. &lt;/p&gt;

&lt;p&gt;Getting Heroku to serve your Angular application is pretty simple but does require a little bit of configuration. Moreover, these same steps could work for any front-end project, not just Angular.&lt;/p&gt;

&lt;p&gt;This article assumes: &lt;br&gt;
You have a Heroku account &lt;br&gt;
You have the &lt;a href="https://toolbelt.heroku.com/"&gt;Heroku Toolbelt&lt;/a&gt; installed on your machine&lt;/p&gt;

&lt;h4 id="addexpress"&gt;Add Express&lt;/h4&gt;

&lt;p&gt;Firstly, you'll want to &lt;code&gt;npm install --save express gzippo&lt;/code&gt; in your project directory.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://www.npmjs.com/package/express"&gt;Express&lt;/a&gt; is a node-based web server which Heroku will use to serve your application files.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://www.npmjs.com/package/gzippo"&gt;Gzippo&lt;/a&gt; allows you to compress (gzip) the files before they are sent on the wire to reduce the size, improving performance.&lt;/p&gt;

&lt;h4 id="createanexpressserverfile"&gt;Create an Express server file&lt;/h4&gt;

&lt;p&gt;Create a file named &lt;code&gt;web.js&lt;/code&gt; in your project root. In this file, add the following lines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gzippo = require('gzippo');
var express = require('express');
var morgan = require('morgan');
var app = express();

app.use(morgan('dev'));
app.use(gzippo.staticGzip("" + __dirname + "/dist"));

app.route('/*').get( function(req, res) {
    return res.sendFile(__dirname + "/dist/index.html");
});

app.listen(process.env.PORT || 5000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This file includes necessary dependencies, and configures Express to respond to all requests with the file at the path in the res.sendFile method. You will need to update this path according to where your final application bundle resides.&lt;/p&gt;

&lt;h4 id="addprocfileandupdatepackagejson"&gt;Add Procfile and Update package.json&lt;/h4&gt;

&lt;p&gt;Heroku relies on a file called &lt;code&gt;Procfile&lt;/code&gt; to know how to start your application. Note that &lt;a href="https://devcenter.heroku.com/articles/procfile"&gt;Procfile&lt;/a&gt; has no file extension. &lt;br&gt;
To this file, you just need to add &lt;code&gt;web: node web.js&lt;/code&gt;. Web lets Heroku know that you want to serve HTTP content, and the remainder is command to invoke node with the Express file you created in the previous step.&lt;/p&gt;

&lt;h4 id="pushtoheroku"&gt;Push to Heroku&lt;/h4&gt;

&lt;p&gt;Before you push to Heroku, it's always a good idea to run &lt;code&gt;heroku local&lt;/code&gt; to &lt;a href="https://devcenter.heroku.com/articles/heroku-local"&gt;make sure&lt;/a&gt; your configuration is correct. If everything looks good then you can &lt;code&gt;git push heroku master&lt;/code&gt;. If that completes successfully you are good to go!&lt;/p&gt;</description><link>http://localhost:2368/publish-your-angular-app-to-heroku/</link><guid isPermaLink="false">15e168b2-d1c8-40ad-95ce-56b41f50e936</guid><category>node</category><category>angular</category><category>heroku</category><dc:creator>Jake Gardner</dc:creator><pubDate>Sat, 05 Dec 2015 05:45:41 GMT</pubDate></item><item><title>Configuration files for your Node.js apps</title><description>&lt;p&gt;For any Node.js application that interacts with external resources (APIs, databases, etc), you will likely need some environment-specific configuration. Now, hopefully you are not hard-coding these values!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            // BAD! 
            mongodb.hostname = "databaseserver";
            mongodb.port = "27017";
            mongodb.database = "mydatabase";
            ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Storing these values in an external file makes it easy to change environments without having to modify the code. Fortunately, &lt;a href="https://nodejs.org/api/modules.html#modules_modules"&gt;require&lt;/a&gt; makes it easy to load values from .js or .json files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            // Better!
            var config = require('./dbconfig.js');

            mongodb.hostname = config.hostname;
            mongodb.port = config.port;
            mongodb.database = config.database;
            ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Require will parse either .js or .json files and return an object you can use in your code. &lt;/p&gt;

&lt;p&gt;Why choose .js or .json? I prefer to use .js for configuration while only use .json  for data (for example, &lt;a href="https://github.com/junit-team/junit/wiki/Test-fixtures"&gt;test fixtures&lt;/a&gt;). However, both formats achieve the same result.&lt;/p&gt;

&lt;h6 id="jsformat"&gt;.js format&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;            exports.hostname = "myserver";
            exports.port = "27017";
            exports.database = "mydatabase";
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id="jsonformat"&gt;.json format&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;            {
              "hostname": "myserver",
              "port": "27017",
              "database": "mydatabase"
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Knowing how easy this is to use, hope you will make use of external configuration files in your Node.js apps!&lt;/p&gt;</description><link>http://localhost:2368/configuration-files-for-your-node-js-apps/</link><guid isPermaLink="false">5a2060fe-ca31-46b7-ae7a-9fb852327856</guid><category>node</category><dc:creator>Jake Gardner</dc:creator><pubDate>Sun, 01 Nov 2015 13:19:33 GMT</pubDate></item><item><title>Implementing Token-Based Authentication using Angular + Node.js</title><description>&lt;p&gt;You are building an authenticated Angular application with a REST backend. You need to restrict access to your server. What do you do?&lt;/p&gt;

&lt;p&gt;Token-based authentication is a very common solution to this problem. Many prominent public API's such as Twitter and Instagram utilize token-based authentication.&lt;/p&gt;

&lt;p&gt;But first, you may ask...&lt;/p&gt;

&lt;h3 id="whataretokens"&gt;What are tokens?&lt;/h3&gt;

&lt;p&gt;A token is a server-generated string that is uniquely associated with a user and identifies them as authenticated. The string can encode certain user-specific informated such as username and profile.&lt;/p&gt;

&lt;p&gt;When a user makes a request to your server, they can provide their token as proof that the server has verified their access.&lt;/p&gt;

&lt;h3 id="whyaretheypreferred"&gt;Why are they preferred?&lt;/h3&gt;

&lt;p&gt;Previously, session-based authentication was the most popular. It is still used in some scenarios, but is more complicated to configure, scale, and secure. Information about logged-in users must be kept in memory, oftentimes in a database such as &lt;a href="http://redis.io/"&gt;Redis&lt;/a&gt;. When a request is received, the user's information must be queried in the session database. &lt;/p&gt;

&lt;p&gt;There are problems with this approach. If the server crashes, this information is lost. The user must re-authenticate and the server must re-construct the session profile. Also, since session information must be stored for every user, with a high volume of users you can quickly run into memory issues.&lt;/p&gt;

&lt;p&gt;Whereas session-based authentication is &lt;em&gt;stateful&lt;/em&gt;, token-based authentication follows a &lt;em&gt;stateless&lt;/em&gt; paradigm. This just means that the server does not keep any information about users in memory. When a request is received, the token is validated. If it passes, the request is completed and a result returned. If not, the server can return an error. No in-memory database is required.&lt;/p&gt;

&lt;p&gt;Authentication is a topic with many, many considerations. If you are looking to understand more of why and how tokens work, check out &lt;a href="https://scotch.io/tutorials/the-ins-and-outs-of-token-based-authentication"&gt;this&lt;/a&gt; article over on &lt;a href="https://scotch.io/tutorials/the-ins-and-outs-of-token-based-authentication"&gt;scotch.io&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Now, let's get into the how-to.&lt;/p&gt;

&lt;h3 id="serversidesetupnodejs"&gt;Server-side setup (Node.js)&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/auth0/node-jsonwebtoken"&gt;Node-jsonwebtoken&lt;/a&gt; is the de-facto module for token functionality in a node application. &lt;/p&gt;

&lt;p&gt;To grab that, you just need to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save jsonwebtoken
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In your node server file, add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var jwt = require('jsonwebtoken');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You also need to set a json web token 'secret'. This string is used to make the tokens that your server generates unique, so preferably make it complex!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var jwtSecret = 'jsonWebTokensAreAGreatIdea!';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now all that's left is to create the token!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var token = jwt.sign('username', jwtSecret, {
    expiresInMinutes: 60
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In place of the 'username' string, you could use an object instead. The second parameter is the secret you configured earlier. The last one is an options object (of which &lt;a href="https://www.npmjs.com/package/jsonwebtoken#jwt-sign-payload-secretorprivatekey-options"&gt;there are many available&lt;/a&gt;); here we just set the expiration time of the token in minutes.&lt;/p&gt;

&lt;p&gt;All of the preceding code together in an Express route:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var app = require('express')();
var jwt = require('jsonwebtoken');
var jwtSecret = 'jsonWebTokensAreAGreatIdea!'; 

app.get('/auth', function (req, res) {
  var username = req.query.username;
  var token = jwt.sign(username, jwtSecret, {
    expiresInMinutes: 60
  });

  res.send(token);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when  a request is received at &lt;a href="http://yourserver/auth?username=jakeg"&gt;http://yourserver/auth?username=jakeg&lt;/a&gt;, a token will be signed and returned to the client.&lt;/p&gt;

&lt;h3 id="clientsidesetupangular"&gt;Client-side setup (Angular)&lt;/h3&gt;

&lt;p&gt;On the Angular side, you first need to setup the request to retrieve the token. Here, I will just use $http.get():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$http.get('http://yourserver/auth', { 
    params: { username: 'username' } 
  }).success( function(data, status, headers, config) {
    // save the token for later queries
    localStorage.token = data.token;
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first parameter to $http.get is the API endpoint that will return the token. The second passes the username within a 'params' object. We save the resulting token in localStorage to persist on the client, but you could pass the token anywhere else in your application deemed appropriate.&lt;/p&gt;

&lt;p&gt;If you want to retrieve the information encoded in the token, you need a couple extra functions to parse and decode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function urlBase64Decode(str) {
  var output = str.replace('-', '+').replace('_', '/');
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += '==';
      break;
    case 3:
      output += '=';
      break;
    default:
      throw 'Illegal base64url string!';
  }
  return window.atob(output);
}

function getClaimsFromToken(token) {
  var response = {};

  if (typeof token !== "undefined") {
    var encoded = token.split(".")[1];
    response = JSON.parse(urlBase64Decode(encoded));
  }
  return response;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first function decodes the token string using base64. The second takes the chunk containing encoded data and parses it into a JSON object.&lt;/p&gt;

&lt;p&gt;To include the token on remote requests (required!), just add it as a parameter. With Angular, you have two options:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://docs.angularjs.org/api/ng/service/$http"&gt;$http.get()&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$http.get('http://myapi.com/auth', 
  { params: { username: 'username' } } );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="https://docs.angularjs.org/api/ngResource/service/$resource"&gt;$resource service&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myResource.bind( { token: localStorage.getItem("token") } );
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;You can also add it as a HTTP Header parameter. However, this will send your token on every HTTP request your application makes. &lt;em&gt;Only&lt;/em&gt; do this if you will only make remote requests to &lt;em&gt;your&lt;/em&gt; API. Sending your token elsewhere can interfere with communication and is also giving away keys to your service!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That's it! Now when you make remote requests, the token your application retrieved earlier will be sent along to authenticate your request.&lt;/p&gt;

&lt;h3 id="wrapup"&gt;Wrap Up&lt;/h3&gt;

&lt;p&gt;Implementing token-based authentication is a good solution toward keeping your application and services secure. And fortunately, the Node and Angular ecosystem makes this fairly simple to setup!&lt;/p&gt;</description><link>http://localhost:2368/implement-token-based-authentication-using-angular-node-js/</link><guid isPermaLink="false">71bd1a9b-ae33-4625-9938-5083eae600d9</guid><category>node</category><category>angular</category><category>token-based auth</category><dc:creator>Jake Gardner</dc:creator><pubDate>Fri, 24 Jul 2015 11:53:14 GMT</pubDate></item><item><title>Authenticate User with Instagram API</title><description>&lt;p&gt;Recently, I was working with the Instagram API for one of my side-projects. This is a short walkthrough of how to implement the &lt;a href="https://instagram.com/developer/authentication/"&gt;server-side flow&lt;/a&gt; of Instagram user authentication in Node.js. &lt;/p&gt;

&lt;p&gt;In order for your application to make queries to the &lt;a href="https://instagram.com/developer"&gt;Instagram API&lt;/a&gt; on your user's behalf, they must authorize your application by logging in with their Instagram credentials. Your application will receive an authorization code in return, and you then need to authenticate this code with Instagram to receive an access token. The access token grants you access to query the REST API.&lt;/p&gt;

&lt;p&gt;Instagram requires that the authentication query be sent as form data (&lt;a href="http://www.w3.org/TR/html5/forms.html#url-encoded-form-data"&gt;x-www-form-urlencoded&lt;/a&gt;) instead of JSON. The documentation shows how to make the query using curl -- since I was doing this in Node, I installed a module called &lt;a href="http://unirest.io/nodejs.html"&gt;unirest&lt;/a&gt;. Here's the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var unirest = require('unirest');
unirest.post("https://api.instagram.com/oauth/access_token")
      .send("client_id=XXXXXXXXXXXXXXXXXXXXXX")
      .send("client_secret=XXXXXXXXXXXXXXXXXX")
      .send("grant_type=authorization_code")
      .send("redirect_uri=http://url.me")
      .send("code=XXXXXXXXXXXXXXXXXXXXXXXXXXXX")
      .end(function (response) {
        console.log(response.body);
      }); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In response, you will receive a JSON object similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        "access_token":"fb2e77d.47a0479900504cb3ab4a1f626d174d2d",
        "user": {
            "id": "1000000",
            ...
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you query one of the Instagram API endpoints, include the access_token as a query (URL) parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unirest.get("https://api.instagram.com/v1/users/self/feed")
     .query("access_token=fb2e77d.47a0479900504cb3ab4a1f626d174d2d")
      .end(function(response) {
        console.log(response);
      });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will probably consume the response instead of log to the console, but you get the idea!&lt;/p&gt;</description><link>http://localhost:2368/authenticate-user-with-instagram-api/</link><guid isPermaLink="false">35c2dd0d-174e-431e-adbf-f18c4cfcc07c</guid><category>node</category><dc:creator>Jake Gardner</dc:creator><pubDate>Fri, 05 Jun 2015 11:34:45 GMT</pubDate></item></channel></rss>