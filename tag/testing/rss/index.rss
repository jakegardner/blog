<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>testing - Jake Gardner</title><description>Explorations in development.</description><link>http://localhost:2368/</link><generator>Ghost 0.5</generator><lastBuildDate>Thu, 03 Mar 2016 07:24:29 GMT</lastBuildDate><atom:link href="http://localhost:2368/tag/testing/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Testing CLI Tools</title><description>&lt;p&gt;While I was developing the &lt;a href="https://www.npmjs.com/package/s3syncr"&gt;s3syncr&lt;/a&gt; command-line (CLI) utility, I discovered I needed a way to test the function of the program as a whole. There are separate tests for the parsing of input to the program, but I wanted to verify the interaction of all the components as well as the output. &lt;/p&gt;

&lt;p&gt;Since console output is the only interface given to the user in a CLI tool, consistent output is critical.&lt;/p&gt;

&lt;p&gt;So, I made use of Node to run the utility inside a Mocha test.&lt;/p&gt;

&lt;h4 id="nodeexec"&gt;Node exec()&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;describe("No parameters", function() {
    it("should output No operation", function(done) {
        require('child_process').exec("node index.js",  
            function(err, stdout, stderr) {
              assert(err);
              assert.strictEqual(stderr, "No operation\n");
              done();  
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This test uses the Node-native &lt;a href="https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback"&gt;child_process.exec&lt;/a&gt; method which runs a shell command and gives you access to what is written to console.log() and console.error() through the &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; parameters, respectively. You can also pass in an options object to specify current working directory, environment variables and so on.&lt;/p&gt;

&lt;h4 id="assertingoutput"&gt;Asserting Output&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;assert.strictEqual(stderr, "No operation\n");
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that console output is available, to execute tests you just need to assert on &lt;code&gt;stdout&lt;/code&gt; or &lt;code&gt;stderr&lt;/code&gt; string content. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assert(err);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use the &lt;code&gt;err&lt;/code&gt; parameter to check for uncaught exceptions.&lt;/p&gt;

&lt;h4 id="automatinginput"&gt;Automating Input&lt;/h4&gt;

&lt;p&gt;Using exec() in the before and after &lt;a href="https://mochajs.org/#hooks"&gt;test hooks&lt;/a&gt; to handle varying test input gives you a path towards comprehensive automated testing!&lt;/p&gt;

&lt;p&gt;For example, you can have some tests that create a file, run the test, and then remove the file afterwards.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beforeEach(function(done) {
    require('child_process').exec("echo 'test' &amp;gt; test.txt", 
        function(err, stdout, stderr) {
            done();
    });
});

afterEach(function(done) {
    require('child_process').exec("rm test.txt", 
        function(err, stdout, stderr) {
            done();
    });
});

it("should output something", function(done) {
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="wrapup"&gt;Wrap Up&lt;/h4&gt;

&lt;p&gt;If you write any kind of CLI, this is a simple way to verify output.&lt;/p&gt;

&lt;p&gt;Honestly, this kind of test could be done in any scripting language, but using Node and Mocha allowed me to integrate with the rest of the testing suite.&lt;/p&gt;</description><link>http://localhost:2368/testing-cli-tools/</link><guid isPermaLink="false">c1447f66-a81e-4c93-b108-e6489972050b</guid><category>node</category><category>testing</category><dc:creator>Jake Gardner</dc:creator><pubDate>Tue, 15 Dec 2015 13:17:10 GMT</pubDate></item></channel></rss>