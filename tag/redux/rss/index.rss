<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>redux - Jake Gardner</title><description>Explorations in development.</description><link>http://localhost:2368/</link><generator>Ghost 0.5</generator><lastBuildDate>Sat, 07 Jan 2017 06:27:24 GMT</lastBuildDate><atom:link href="http://localhost:2368/tag/redux/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Redux: Thunk vs. Saga</title><description>&lt;p&gt;Two of the most common ways of dealing with side effects in Redux applications today are thunks and sagas.&lt;/p&gt;

&lt;h3 id="thunkyougotfunctionallinmyactions"&gt;Thunk: You Got Function All In My Actions&lt;/h3&gt;

&lt;p&gt;Most people will ask, what's a thunk? And why do I need it?&lt;/p&gt;

&lt;p&gt;The most straightforward explanation of a thunk I've seen is by Kyle Simpson (of You Don't Know JS fame) in his &lt;a href="https://frontendmasters.com/courses/rethinking-async-js/"&gt;Rethinking Asynchronous Javascript&lt;/a&gt; course for Front End Masters (highly recommended!).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A thunk is a function that already has everything it needs to execute.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;What does that have to do with redux thunk? I'm not sure either.&lt;/p&gt;

&lt;p&gt;As you know, in Redux, actions are defined by JSON. Redux-thunk allows you to send a function instead. Rather than [only] prescribe a state change for the reducer to carry out, you can write some logic to execute immediately and dispatch other actions. &lt;/p&gt;

&lt;p&gt;This is great for small use cases, however for more than a few functions, a better approach is &lt;a href="http://redux.js.org/docs/advanced/Middleware.html"&gt;middleware&lt;/a&gt; ... or sagas.&lt;/p&gt;

&lt;h6 id="howdoiusethisthing"&gt;How do I use this thing?&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;Add the redux-thunk middleware to the store.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { createStore, applyMiddleware, compose } from "redux";  
import thunkMiddleware from "redux-thunk";  
import rootReducer from "../reducers";

const createStoreWithMiddleware = compose(  
  applyMiddleware(thunkMiddleware)
)(createStore);

export default function configureStore(initialState) {  
  const store = createStoreWithMiddleware(rootReducer);
  return store;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;configureStore.js&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This file just exports a function that returns the store to be added to the Provider element.&lt;/p&gt;

&lt;p&gt;Using compose to create the createStoreWithMiddleware function is just a fancier way of writing  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const store = createStore(  
    rootReducer,
    applyMiddleware(thunkMiddleware)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Write an action that returns a function.&lt;/strong&gt; This function will take the dispatch method as a parameter. You can use this to call subsequent actions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import * as types from "../constants/ActionTypes";

export function receiveBooks(data) {  
  return {
    type: types.RECEIVE_BOOKS,
    books: data.books,
    categories: data.categories,
    genres: data.genres
  };
}

export function fetchBooks() {  
  return dispatch =&amp;gt; {
    fetch("/books.json").then(response =&amp;gt; {
        const data = response.json();
        dispatch(receiveBooks(data));
    })
    .catch(error =&amp;gt; 
        dispatch({ type: types.FETCH_FAILED, error })
    );
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;book-actions.js&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In this action creator file, we have one standard action, receiveBooks() and one thunk(ed) action, fetchBooks(). fetchBooks() just defines an arrow function taking dispatch as a parameter. The receiveBooks action is dispatched on success.&lt;/p&gt;

&lt;h3 id="sagaaheroictaleofdispatching"&gt;Saga: A Heroic Tale Of Dispatching&lt;/h3&gt;

&lt;p&gt;"Again with the names, what's a saga?!" If you are or were a fan of fantasy or science fiction, you already know. For the others, a saga is just a series of connected stories.&lt;/p&gt;

&lt;p&gt;For the case of &lt;a href="https://github.com/yelouafi/redux-saga"&gt;redux-saga&lt;/a&gt;, I'll let the README do the honor:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sagas are responsible for orchestrating complex/asynchronous operations.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sagas are created using Generator functions.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since sagas take advantage of the yield keyword to halt execution within a function, they empower you to write the steps necessary to complete your action and let the Javascript engine manage the execution. &lt;/p&gt;

&lt;p&gt;Executing functions in series can otherwise be tricky, your other option being a promise chain.&lt;/p&gt;

&lt;h6 id="howdoiusethisthing"&gt;How do I use this thing?&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;Add redux-saga middleware to the store.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { createStore, applyMiddleware, compose } from "redux";  
import createSagaMiddleware from "redux-saga";  
import rootReducer from "../reducers";

const sagaMiddleware = createSagaMiddleware();

const createStoreWithMiddleware = compose(  
  applyMiddleware(sagaMiddleware)
)(createStore);

export default function configureStore(initialState) {  
  const store = createStoreWithMiddleware(rootReducer);
  return store;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;configureStore.js&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Define your saga.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { takeLatest } from "redux-saga"  
import { call, put } from "redux-saga/effects"

function* fetchBooks(path) {  
   try {
      const data = yield call(fetch, path);
      yield put({type: "RECEIVE_BOOKS", data });
   } catch (e) {
      yield put({type: "FETCH_FAILED", message: e.message});
   }
}

function* fetchSaga() {  
  yield* takeLatest("FETCH_BOOKS", fetchBooks);
}

export default fetchSaga;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;sagas/index.js&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;fetchSaga() listens for all FETCH_BOOKS actions and calls fetchBooks() once received. takeLatest() just means that if there are multiple actions fired, the most recent will be run and previous ones will be cancelled.&lt;/p&gt;

&lt;p&gt;What's the benefit of using a saga here?&lt;/p&gt;

&lt;p&gt;Since fetchBooks() as a saga is a Generator function, the call to the fetch api with the yield keyword will block until the promise is resolved. Also, since it is blocking, we can make use of try/catch for error handling.&lt;/p&gt;

&lt;p&gt;Another benefit is testing. The call and put methods return javascript objects, so in unit tests you can simply test each value yielded by your saga function with equality comparison. Testing thunks often requires complex mocking of the fetch api or other functions.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Import and run saga.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { createStore, applyMiddleware, compose } from "redux";  
import createSagaMiddleware from "redux-saga";  
import rootReducer from "../reducers";  
import fetchSaga from "../sagas";

const sagaMiddleware = createSagaMiddleware();

const createStoreWithMiddleware = compose(  
  applyMiddleware(sagaMiddleware)
)(createStore);

export default function configureStore(initialState) {  
  const store = createStoreWithMiddleware(rootReducer);
  sagaMiddleware.run(fetchSaga);
  return store;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;configureStore.js&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Since we already added the saga middleware to the store, the only thing that remains is to import and run the saga we defined.&lt;/p&gt;</description><link>http://localhost:2368/redux-thunk-vs-saga/</link><guid isPermaLink="false">f527e9a6-e071-40e5-81a3-1bacc8433f28</guid><category>redux</category><dc:creator>Jake Gardner</dc:creator><pubDate>Thu, 07 Jul 2016 00:49:43 GMT</pubDate></item><item><title>Extract Fetch calls with Redux Middleware</title><description>&lt;p&gt;The first thing a lot of people coming to the React side-of-things ask is, "what about async actions?" (I did too). &lt;br&gt;
Since React is unopinionated on this point, you can do it however you like. &lt;/p&gt;

&lt;p&gt;However, since I use Redux for any substantial application I develop with React, I wanted to find a good pattern to use to handle asynchronous behavior that takes advantage of the plumbing available.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I specifically use &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"&gt;Web API Fetch&lt;/a&gt; in this article, but any HTTP request library could be substituted.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id="asyncactioncreators"&gt;Async Action Creators&lt;/h4&gt;

&lt;p&gt;A pattern offered in the Redux documentation is to have some action creators perform these asynchronous actions for you. I initially used this pattern.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A pre-requisite here is to include the &lt;a href="https://github.com/gaearon/redux-thunk"&gt;redux-thunk&lt;/a&gt; middleware. All this does is allow you to dispatch a function in addition to plain objects. See &lt;a href="https://github.com/gaearon/redux-thunk"&gt;this&lt;/a&gt; for more details.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Your asynchronous action creator will be something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export function fetchData(itemId) {  
    return dispatch =&amp;gt; {
        fetch(`${API}/items/${itemId}`, {
            method: "GET",
            headers: new Headers({
                "Authorization": `Bearer ${TOKEN}`
            })
        })
        .then( response =&amp;gt; response.json() )
        .then( json =&amp;gt; dispatch(fetchDataSuccess(json)) )
        .catch( error =&amp;gt; dispatch(fetchDataFailure(error)) );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in contrast to standard synchronous action creators which return a plain object, you return a function which takes dispatch as a parameter. Inside this function you perform your asynchronous behavior and potentially dispatch another function on completion.&lt;/p&gt;

&lt;p&gt;With any substantial application, the number of these kinds of actions can grow wildly. Furthermore, they can be quite verbose depending on what parameters we need to pass to Fetch. Being diligent programmers that we are, we recognize this is an opportunity to eliminate redundancy by extracting these Fetch calls elsewhere.&lt;/p&gt;

&lt;p&gt;You could easily create a module an just require it in every action file, but that approach also has some degree of repetition. Fortunately, Redux's middleware mechanism is designed for just this type of situation.&lt;/p&gt;

&lt;h4 id="fetchmiddleware"&gt;Fetch Middleware&lt;/h4&gt;

&lt;p&gt;Let's create a middleware that performs the Fetch if a Fetch parameter object exists in the action. We can define the properties of this object however we like. I have just included the most common Fetch parameters as well as success and failure handlers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fetchMiddleware = store =&amp;gt; next =&amp;gt; action =&amp;gt; {  
    if (!action || !action.fetchConfig) {
        return next(action)
    }

    let dispatch = store.dispatch
    let config = action.fetchConfig
    dispatch(config.init)

    const path = config.path || "/"
    const method = config.method || "GET"
    const headers = config.headers
    const body = config.body
    const successHandler = config.success
    const failureHandler = config.failure

    fetch(path, {
        method: method,
        headers: headers,
        body: JSON.stringify(body)
    })
    .then( response =&amp;gt; response.json() )
    .then( json =&amp;gt; successHandler(json) )
    .catch( error =&amp;gt; failureHandler(error) )

}

export default fetchMiddleware  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A middleware is defined as a function that takes the store as a parameter, returns a function which takes the next middleware as parameter, which in turn returns a function that takes an action to run. (mind bent yet?)&lt;/p&gt;

&lt;p&gt;For a detailed walkthrough of how middleware works and a number of other use cases, see the excellent write-up  &lt;a href="http://redux.js.org/docs/advanced/Middleware.html"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So we just check for the existence of fetchConfig on the action and proceed if so. If not, then we hand off to the next middleware.&lt;/p&gt;

&lt;p&gt;Our function just takes apart the config object and sets any defaults as necessary. Then, execute the Fetch call and any handlers for Promise resolution.&lt;/p&gt;

&lt;p&gt;If your success/failure handler is another action, you can just change the then/catch block to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    .then( json =&amp;gt; {
        dispatch(successHandler(json))
    })
    .catch( error =&amp;gt; dispatch(failureHandler(error)) )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we can include our middleware in the createStore method to ensure it's called as part of the action flow.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let app = combineReducers(reducers)  
let store = createStore(  
  app,
  applyMiddleware(thunk, fetchMiddleware)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, we just update the action creator to pass the fetchConfig object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export function fetchData(itemId) {  
    return {
        type: "FETCH_ITEM",
        fetchConfig: {
            path: `${API}/items/${itemId}`,
            method: "GET",
            headers: {
                "Authorization": `Bearer ${TOKEN}`
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/consolidate-fetch-with-redux-middleware/</link><guid isPermaLink="false">3a909a86-bad6-4185-98bc-7ad281fa4b6f</guid><category>redux</category><dc:creator>Jake Gardner</dc:creator><pubDate>Mon, 11 Apr 2016 23:06:02 GMT</pubDate></item><item><title>Routing with Redux</title><description>&lt;p&gt;Last weekend I put together my first Redux &lt;a href="https://github.com/jakegardner/redux-bookcatalog"&gt;application&lt;/a&gt; by refactoring an old demo. Once you get familiar, the architecture seems like a very natural way to build applications.&lt;/p&gt;

&lt;p&gt;One area that took some time to figure out was that of routing. While you can use &lt;a href="https://github.com/rackt/react-router"&gt;react-router&lt;/a&gt;, you need to do some extra wiring to get your state flowing as you would expect with vanilla React. &lt;/p&gt;

&lt;p&gt;There are two projects to provide a seamless integration with Redux architecture, &lt;a href="https://github.com/acdlite/redux-router"&gt;redux-router&lt;/a&gt; and &lt;a href="https://github.com/rackt/redux-simple-router"&gt;redux-simple-router&lt;/a&gt;. Redux-router, at time of writing, is considered experimental, so I went with the redux-simple-router. It integrates seamlessly with react-router and redux.&lt;/p&gt;

&lt;p&gt;I flet that some details were missing from documentation of integrating these projects, so I'm writing this simple how-to in the hopes that it helps someone else in the same situation in the future :)&lt;/p&gt;

&lt;h4 id="background"&gt;Background&lt;/h4&gt;

&lt;p&gt;Here I will provide some information on the components you need to get this working, namely react-router and redux-simple-router.&lt;/p&gt;

&lt;h6 id="reactrouter"&gt;React-router&lt;/h6&gt;

&lt;p&gt;The key rendered component of &lt;a href="https://github.com/rackt/react-router"&gt;react-router&lt;/a&gt; is the Router:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Router /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside your Router element, you will put one or more Route elements: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Router&amp;gt;
    &amp;lt;Route path="/" component={App} /&amp;gt;
&amp;lt;/Router&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each Route element can also have child routes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Router&amp;gt;
    &amp;lt;Route path="/" component={App}&amp;gt;
            &amp;lt;Route path="home" component={Home} /&amp;gt;
    &amp;lt;/Route&amp;gt;
&amp;lt;/Router&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you might expect, each Route element defines the expected route and the component should be rendered when hitting that route.&lt;/p&gt;

&lt;p&gt;Where do the routes get rendered?&lt;/p&gt;

&lt;p&gt;In the render method of a component with child routes (e.g. App in the above example), you will add something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    {this.props.children}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;{this.props.children}&lt;/code&gt; identifies where in the render method child routes should be rendered. So for the /home route, the Home component would replace the contents of this div. &lt;/p&gt;

&lt;h6 id="reduxsimplerouter"&gt;Redux-simple-router&lt;/h6&gt;

&lt;p&gt;Redux-simple-router simply (ha!) stores your router state in your Redux store. So, whereever you have connected a React component to your store, you can access routing parameters, path etc as a property of state i.e. &lt;code&gt;state.router&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is enabled by this statement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;syncReduxAndRouter(history, store, (state) =&amp;gt; state.router);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should be included where you create your store. Don't worry; there is an example coming.&lt;/p&gt;

&lt;h4 id="letsmakethishappen"&gt;Let's make this happen&lt;/h4&gt;

&lt;p&gt;Now that we have some fundamental understanding, let's apply it.&lt;/p&gt;

&lt;h6 id="installreactrouterreduxsimplerouter"&gt;Install react-router, redux-simple-router&lt;/h6&gt;

&lt;p&gt;If you haven't already, run these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save react-router
npm install --save redux-simple-router
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id="setupreduxsimplerouter"&gt;Setup redux-simple-router&lt;/h6&gt;

&lt;p&gt;The following should be in your application entry point file (I call mine index.js).&lt;/p&gt;

&lt;p&gt;This is where the store is created, and the syncReduxAndRouter function is called.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React, { Component, PropTypes } from "react";
import { render } from "react-dom";
import { createHistory, useBasename } from "history";
import { syncReduxAndRouter } from "redux-simple-router";
import routes from "./routes";
import Root from "./containers/Root";
import configureStore from "./store/configureStore";

const history = useBasename(createHistory)({
  basename: JSON.stringify(process.env.BASENAME || "/")
});
const store = configureStore();

syncReduxAndRouter(history, store, (state) =&amp;gt; state.router);

render(
  &amp;lt;Root history={history} routes={routes} store={store} /&amp;gt;,
  document.getElementById("root")
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After syncing redux and the router, the routes and store are passed as props to the Root container (component).&lt;/p&gt;

&lt;p&gt;The store parameter is the &lt;a href="http://rackt.org/redux/docs/api/Store.html"&gt;Redux store&lt;/a&gt; returned by createStore(). The history parameter is created by createHistory(). The routes parameter are the routes defined as &lt;a href="https://facebook.github.io/jsx/"&gt;JSX&lt;/a&gt; in another file (see below). These can also be specified inline.&lt;/p&gt;

&lt;h6 id="addrouterelement"&gt;Add Router element&lt;/h6&gt;

&lt;p&gt;In the Root component file, and inside of your &lt;a href="http://localhost:2368/"&gt;Provider&lt;/a&gt; element, add the Router element:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Provider store={this.props.store}&amp;gt;
    &amp;lt;Router history={this.props.history}&amp;gt;
      {this.props.routes}
    &amp;lt;/Router&amp;gt;
&amp;lt;/Provider&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The props in this snippet are the same that we defined and passed in the previous code sample.&lt;/p&gt;

&lt;p&gt;So the full Root component source should look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  import React, { Component, PropTypes } from "react";
  import { Provider } from "react-redux";
  import { Router } from "react-router";

  class Root extends Component {
    render() {
      return (
        &amp;lt;Provider store={this.props.store}&amp;gt;
          &amp;lt;Router history={this.props.history}&amp;gt;
            {this.props.routes}
          &amp;lt;/Router&amp;gt;
        &amp;lt;/Provider&amp;gt;
      );
    }
  }
  Root.propTypes = {
    history: PropTypes.object.isRequired,
    routes: PropTypes.element.isRequired,
    store: PropTypes.object.isRequired
  };

export default Root;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id="configureroutes"&gt;Configure routes&lt;/h6&gt;

&lt;p&gt;Now to define the routes. Add a top-level route and any needed sub-routes: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Route path="/" component={App}&amp;gt;
    &amp;lt;IndexRoute component={Home} /&amp;gt;
    &amp;lt;Route path="/book/:bookId" component={Detail} /&amp;gt;
&amp;lt;/Route&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parent &lt;a href="https://github.com/rackt/react-router/blob/latest/docs/guides/basics/RouteConfiguration.md"&gt;Route&lt;/a&gt; element with the root path encloses any other routes in your application.&lt;/p&gt;

&lt;p&gt;The &lt;a href="https://github.com/rackt/react-router/blob/latest/docs/guides/basics/IndexRoutes.md"&gt;IndexRoute&lt;/a&gt; is a special element that allows you to specify which component should receive the request with no additional route information, i.e. the root path. Even though this element specifies the destination, I found that the path and component properties in the parent Route element were required.&lt;/p&gt;

&lt;p&gt;Finally, the child Route element specifies a sub-route of the root with a route parameter indicated by the leading colon. This parameter will be available as &lt;code&gt;state.router.params.bookId&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The full routes source file should look like: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React, { Component, PropTypes } from "react";
import { Route, IndexRoute } from "react-router";
import App from "../components/App";
import Home from "../components/Home";
import Detail from "../components/Detail";

export default (
      &amp;lt;Route path="/" component={App}&amp;gt;
        &amp;lt;IndexRoute component={Home} /&amp;gt;
        &amp;lt;Route path="/book/:bookId" component={Detail} /&amp;gt;
      &amp;lt;/Route&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save this as &lt;code&gt;/routes/index.js&lt;/code&gt; or wherever is appropriate, but make sure to update the include path in the Root component file.&lt;/p&gt;

&lt;h6 id="modifystateparameterincomponents"&gt;Modify state parameter in components&lt;/h6&gt;

&lt;p&gt;The final step is to check any components that receive state. Before the routing configuration, your state object may have had the properties you defined at the root of the object. Afterwards, I found that the state object now includes a child object for the router and one for the reducer. Whatever state is returned by the &lt;a href="http://rackt.org/redux/docs/basics/Reducers.html"&gt;reducer&lt;/a&gt; is a child of this child reducer object, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;state = {
    router: {
        changeId: 1,
        path: "/book/12",
        replace: false,
        state: ...
    },
    reducer: {
        *state here*
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reducer will be named after your reducer. Update your props declarations or mapStateToProps methods as appropriate to ensure that &lt;a href="http://rackt.org/redux/docs/basics/DataFlow.html"&gt;state flows&lt;/a&gt; to your components as you expect.&lt;/p&gt;</description><link>http://localhost:2368/routing-with-redux/</link><guid isPermaLink="false">0213fc9b-798c-4a10-a5e2-93ef5e7b4d8f</guid><category>react</category><category>redux</category><dc:creator>Jake Gardner</dc:creator><pubDate>Tue, 12 Jan 2016 05:22:30 GMT</pubDate></item></channel></rss>